/**
 * Coordinates of a decoded Open Location Code.
 *
 * The coordinates include the latitude and longitude of the lower left and
 * upper right corners and the center of the bounding box for the area the
 * code represents.
 *
 * @constructor
 */
export declare class CodeArea {
    latitudeLo: any;
    longitudeLo: any;
    latitudeHi: any;
    longitudeHi: any;
    codeLength: any;
    /**
     * The latitude of the center in degrees.
     */
    latitudeCenter: number;
    /**
     * The longitude of the center in degrees.
     */
    longitudeCenter: number;
    constructor(latitudeLo: any, longitudeLo: any, latitudeHi: any, longitudeHi: any, codeLength: any);
    getLatitudeHeight(): number;
    getLongitudeWidth(): number;
}
/**
 * Open Location Code implementation for TypeScript
 */
export default class OpenLocationCode {
    code: string;
    constructor(code: string);
    getCode(): string;
    /**
     * Returns whether this {@link OpenLocationCode} is a padded Open Location Code, meaning that it
     * contains less than 8 valid digits.
     */
    isPadded(): boolean;
    private static readonly CODE_PRECISION_NORMAL;
    private static readonly CODE_PRECISION_EXTRA;
    private static readonly MAX_DIGIT_COUNT;
    private static readonly SEPARATOR_;
    private static readonly SEPARATOR_POSITION_;
    private static readonly PADDING_CHARACTER_;
    private static readonly CODE_ALPHABET_;
    private static readonly ENCODING_BASE_;
    static readonly LATITUDE_MAX_: number;
    static readonly LONGITUDE_MAX_: number;
    private static readonly PAIR_CODE_LENGTH_;
    private static readonly PAIR_RESOLUTIONS_;
    private static readonly GRID_COLUMNS_;
    private static readonly GRID_ROWS_;
    private static readonly GRID_SIZE_DEGREES_;
    private static readonly MIN_TRIMMABLE_CODE_LEN_;
    /**
     * Determines if a code is valid.
     *
     * To be valid, all characters must be from the Open Location Code character
     * set with at most one separator. The separator can be in any even-numbered
     * position up to the eighth digit.
     *
     * @param {string} code The string to check.
     * @return {boolean} True if the string is a valid code.
     */
    static isValid(code: string): boolean;
    /**
     * Returns whether the provided Open Location Code is a padded Open Location Code, meaning that it
     * contains less than 8 valid digits.
     */
    static isPadded(code: string): boolean;
    /**
     * Determines if a code is a valid short code.
     *
     * @param {string} code The string to check.
     * @return {boolean} True if the string can be produced by removing four or
     *     more characters from the start of a valid code.
     */
    static isShort(code: string): boolean;
    /**
     * Determines if a code is a valid full Open Location Code.
     *
     * @param {string} code The string to check.
     * @return {boolean} True if the code represents a valid latitude and longitude combination.
     */
    static isFull(code: string): boolean;
    contains(latitude: number, longitude: number): boolean;
    /**
     * Encode a location into an Open Location Code.
     *
     * @param {number} latitude The latitude in signed decimal degrees. It will
     *     be clipped to the range -90 to 90.
     * @param {number} longitude The longitude in signed decimal degrees. Will be
     *     normalised to the range -180 to 180.
     * @param {?number} codeLength The length of the code to generate. If
     *     omitted, the value OpenLocationCode.CODE_PRECISION_NORMAL will be used.
     *     For a more precise result, OpenLocationCode.CODE_PRECISION_EXTRA is
     *     recommended.
     * @return {string} The code.
     * @throws {Exception} if any of the input values are not numbers.
     */
    static encode(latitude: number, longitude: number, codeLength?: number): string;
    /**
     * Decodes an Open Location Code into its location coordinates.
     *
     * Returns a CodeArea object that includes the coordinates of the bounding
     * box - the lower left, center and upper right.
     *
     * @param {string} code The code to decode.
     * @return {CodeArea} An object with the coordinates of the
     *     area of the code.
     * @throws {Exception} If the code is not valid.
     */
    static decode(code: string): CodeArea;
    /**
     * Recover the nearest matching code to a specified location.
     *
     * Given a valid short Open Location Code this recovers the nearest matching
     * full code to the specified location.
     *
     * @param {string} shortCode A valid short code.
     * @param {number} latitude The latitude to use for the reference
     *     location.
     * @param {number} longitude The longitude to use for the reference
     *     location.
     * @return {string} The nearest matching full code to the reference location.
     * @throws {Exception} if the short code is not valid, or the reference
     *     position values are not numbers.
     */
    static recoverNearest(shortCode: string, latitude: number, longitude: number): string;
    /**
     * Remove characters from the start of an OLC code.
     *
     * This uses a reference location to determine how many initial characters
     * can be removed from the OLC code. The number of characters that can be
     * removed depends on the distance between the code center and the reference
     * location.
     *
     * @param {string} code The full code to shorten.
     * @param {number} latitude The latitude to use for the reference location.
     * @param {number} longitude The longitude to use for the reference location.
     * @return {string} The code, shortened as much as possible that it is still
     *     the closest matching code to the reference location.
     * @throws {Exception} if the passed code is not a valid full code or the
     *     reference location values are not numbers.
     */
    static shorten(code: string, latitude: number, longitude: number): string;
    /**
     * Clip a latitude into the range -90 to 90.
     *
     * @param {number} latitude
     * @return {number} The latitude value clipped to be in the range.
     */
    private static clipLatitude(latitude);
    /**
     * Compute the latitude precision value for a given code length.
     * Lengths <= 10 have the same precision for latitude and longitude, but
     * lengths > 10 have different precisions due to the grid method having
     * fewer columns than rows.
     * @param {number} codeLength
     * @return {number} The latitude precision in degrees.
     */
    private static computeLatitudePrecision(codeLength);
    /**
     * Normalize a longitude into the range -180 to 180, not including 180.
     *
     * @param {number} longitude
     * @return {number} Normalized into the range -180 to 180.
     */
    private static normalizeLongitude(longitude);
    /**
     * Encode a location into a sequence of OLC lat/lng pairs.
     *
     * This uses pairs of characters (longitude and latitude in that order) to
     * represent each step in a 20x20 grid. Each code, therefore, has 1/400th
     * the area of the previous code.
     *
     * This algorithm is used up to 10 digits.
     *
     * @param {number} latitude The location to encode.
     * @param {number} longitude The location to encode.
     * @param {number} codeLength Requested code length.
     * @return {string} The up to 10-digit OLC code for the location.
     */
    private static encodePairs(latitude, longitude, codeLength);
    /**
     * Encode a location using the grid refinement method into an OLC string.
     *
     * The grid refinement method divides the area into a grid of 4x5, and uses a
     * single character to refine the area. This allows default accuracy OLC codes
     * to be refined with just a single character.
     *
     * This algorithm is used for codes longer than 10 digits.
     *
     * @param {number} latitude The location to encode.
     * @param {number} longitude The location to encode.
     * @param {number} codeLength Requested code length.
     * @return {string} The OLC code digits from the 11th digit on.
     */
    private static encodeGrid(latitude, longitude, codeLength);
    /**
     * Decode an OLC code made up of lat/lng pairs.
     *
     * This decodes an OLC code made up of alternating latitude and longitude
     * characters, encoded using base 20.
     *
     * @param {string} code The code to decode, assumed to be a valid full code,
     *     but with the separator removed.
     * @return {CodeArea} The code area object.
     */
    private static decodePairs(code);
    /**
     * Decode either a latitude or longitude sequence.
     *
     * This decodes the latitude or longitude sequence of a lat/lng pair encoding.
     * Starting at the character at position offset, every second character is
     * decoded and the value returned.
     *
     * @param {string} code A valid full OLC code, with the separator removed.
     * @param {number} offset The character to start from.
     * @return {[number]} An array of two numbers, representing the lower and
     *     upper range in decimal degrees. These are in positive ranges and will
     *     need to be corrected appropriately.
     */
    private static decodePairsSequence(code, offset);
    /**
     * Decode the grid refinement portion of an OLC code.
     *
     * @param {string} code The grid refinement section of a code.
     * @return {CodeArea} The area of the code.
     */
    private static decodeGrid(code);
}
