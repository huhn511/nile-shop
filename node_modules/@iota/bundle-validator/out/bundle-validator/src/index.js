"use strict";
/** @module bundle-validator */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var transaction_converter_1 = require("@iota/transaction-converter");
var errors_1 = require("../../errors");
exports.INVALID_BUNDLE = errors_1.INVALID_BUNDLE;
var guards_1 = require("../../guards");
var HASH_TRITS_SIZE = 243;
/**
 * Validates all signatures of a bundle.
 *
 * @method validateSignatures
 *
 * @param {Transaction[]} bundle
 *
 * @return {boolean}
 */
exports.validateBundleSignatures = function (bundle) {
    var signatures = bundle.slice().sort(function (a, b) { return a.currentIndex - b.currentIndex; }).reduce(function (acc, _a, i) {
        var address = _a.address, signatureMessageFragment = _a.signatureMessageFragment, value = _a.value;
        var _b, _c;
        return value < 0
            ? __assign({}, acc, (_b = {}, _b[address] = [converter_1.trits(signatureMessageFragment)], _b)) : value === 0 && acc.hasOwnProperty(address) && address === bundle[i - 1].address
            ? __assign({}, acc, (_c = {}, _c[address] = acc[address].concat(converter_1.trits(signatureMessageFragment)), _c)) : acc;
    }, {});
    return Object.keys(signatures).every(function (address) {
        return signing_1.validateSignatures(converter_1.trits(address), signatures[address], converter_1.trits(bundle[0].bundle));
    });
};
/**
 * Checks if a bundle is _syntactically_ valid.
 * Validates signatures and overall structure.
 *
 * @method isBundle
 *
 * @param {Transaction[]} bundle
 *
 * @returns {boolean}
 */
function isBundle(bundle) {
    if (!guards_1.isArray(transaction_1.isTransaction)(bundle)) {
        return false;
    }
    var totalSum = 0;
    var bundleHash = bundle[0].bundle;
    var sponge = new kerl_1["default"]();
    // Prepare for signature validation
    var signaturesToValidate = [];
    // Addresses of value txs must have last trit == 0.
    if (bundle.some(function (tx) { return tx.value !== 0 && converter_1.trits(tx.address)[HASH_TRITS_SIZE - 1] !== 0; })) {
        return false;
    }
    // currentIndex has to be equal to the index in the array
    if (bundle.some(function (tx, index) { return tx.currentIndex !== index; })) {
        return false;
    }
    // Txs must have correct lastIndex
    if (bundle.some(function (tx) { return tx.lastIndex !== bundle.length - 1; })) {
        return false;
    }
    bundle.forEach(function (bundleTx, index) {
        totalSum += bundleTx.value;
        // Get the transaction trytes
        var thisTxTrytes = transaction_converter_1.asTransactionTrytes(bundleTx);
        var thisTxTrits = converter_1.trits(thisTxTrytes.slice(2187, 2187 + 162));
        sponge.absorb(thisTxTrits, 0, thisTxTrits.length);
        // Check if input transaction
        if (bundleTx.value < 0) {
            var thisAddress = bundleTx.address;
            var newSignatureToValidate = {
                address: thisAddress,
                signatureFragments: Array(bundleTx.signatureMessageFragment)
            };
            // Find the subsequent txs with the remaining signature fragment
            for (var i = index; i < bundle.length - 1; i++) {
                var newBundleTx = bundle[i + 1];
                // Check if new tx is part of the signature fragment
                if (newBundleTx.address === thisAddress && newBundleTx.value === 0) {
                    newSignatureToValidate.signatureFragments.push(newBundleTx.signatureMessageFragment);
                }
            }
            signaturesToValidate.push(newSignatureToValidate);
        }
    });
    // Check for total sum, if not equal 0 return error
    if (totalSum !== 0) {
        return false;
    }
    // Prepare to absorb txs and get bundleHash
    var bundleFromTxs = new Int8Array(kerl_1["default"].HASH_LENGTH);
    // get the bundle hash from the bundle transactions
    sponge.squeeze(bundleFromTxs, 0, kerl_1["default"].HASH_LENGTH);
    // Check if bundle hash is the same as returned by tx object
    if (converter_1.trytes(bundleFromTxs) !== bundleHash) {
        return false;
    }
    return exports.validateBundleSignatures(bundle);
}
exports["default"] = isBundle;
exports.bundleValidator = function (bundle) { return [bundle, isBundle, errors_1.INVALID_BUNDLE]; };
//# sourceMappingURL=index.js.map