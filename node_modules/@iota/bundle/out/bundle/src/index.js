"use strict";
/** @module bundle */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var pad_1 = require("@iota/pad");
var signing_1 = require("@iota/signing");
var errors_1 = require("../../errors");
require("../../typed-array");
var HASH_TRITS_SIZE = 243;
var NULL_HASH_TRYTES = '9'.repeat(81);
var NULL_TAG_TRYTES = '9'.repeat(27);
var NULL_NONCE_TRYTES = '9'.repeat(27);
var NULL_SIGNATURE_MESSAGE_FRAGMENT_TRYTES = '9'.repeat(2187);
var getEntryWithDefaults = function (entry) { return ({
    length: entry.length || 1,
    address: entry.address || NULL_HASH_TRYTES,
    value: entry.value || 0,
    tag: entry.tag || NULL_TAG_TRYTES,
    timestamp: entry.timestamp || Math.floor(Date.now() / 1000),
    signatureMessageFragments: entry.signatureMessageFragments
        ? entry.signatureMessageFragments.map(pad_1.padTrytes(2187))
        : Array(entry.length || 1).fill(NULL_SIGNATURE_MESSAGE_FRAGMENT_TRYTES)
}); };
/**
 * Creates a bundle with given transaction entries.
 *
 * @method createBundle
 *
 * @param {BundleEntry[]} entries - Entries of single or multiple transactions with the same address
 *
 * @return {Transaction[]} List of transactions in the bundle
 */
exports.createBundle = function (entries) {
    if (entries === void 0) { entries = []; }
    return entries.reduce(function (bundle, entry) { return exports.addEntry(bundle, entry); }, []);
};
/**
 * Adds given transaction entry to a bundle.
 *
 * @method addEntry
 *
 * @param {Transaction[]} transactions - List of transactions currently in the bundle
 *
 * @param {object} entry - Entry of a single or multiple transactions with the same address
 * @param {number} [entry.length = 1] - Entry length, which indicates how many transactions in the bundle it will occupy
 * @param {Hash} [entry.address] - Address, defaults to all-9s
 * @param {number} [entry.value = 0] - Value to transfer in iotas
 * @param {Trytes[]} [entry.signatureMessageFragments] - List of signature message fragments, defaults to all-9s
 * @param {number} [entry.timestamp] - Transaction timestamp, defaults to `Math.floor(Date.now() / 1000)`
 * @param {string} [entry.tag] - Optional Tag, defaults to null tag (all-9s)
 *
 * @return {Transaction[]} List of transactions in the updated bundle
 */
exports.addEntry = function (transactions, entry) {
    var entryWithDefaults = getEntryWithDefaults(entry);
    var length = entryWithDefaults.length, address = entryWithDefaults.address, value = entryWithDefaults.value, timestamp = entryWithDefaults.timestamp, signatureMessageFragments = entryWithDefaults.signatureMessageFragments;
    var lastIndex = transactions.length - 1 + length;
    var tag = pad_1.padTag(entryWithDefaults.tag);
    var obsoleteTag = tag;
    if (value !== 0 && converter_1.trits(address)[HASH_TRITS_SIZE - 1] !== 0) {
        throw new Error(errors_1.INVALID_ADDRESS_LAST_TRIT);
    }
    return transactions.map(function (transaction) { return (__assign({}, transaction, { lastIndex: lastIndex })); }).concat(Array(length)
        .fill(null)
        .map(function (_, i) { return ({
        address: address,
        value: i === 0 ? value : 0,
        tag: tag,
        obsoleteTag: obsoleteTag,
        currentIndex: transactions.length + i,
        lastIndex: lastIndex,
        timestamp: timestamp,
        signatureMessageFragment: signatureMessageFragments[i],
        trunkTransaction: NULL_HASH_TRYTES,
        branchTransaction: NULL_HASH_TRYTES,
        attachmentTimestamp: 0,
        attachmentTimestampLowerBound: 0,
        attachmentTimestampUpperBound: 0,
        bundle: NULL_HASH_TRYTES,
        nonce: NULL_NONCE_TRYTES,
        hash: NULL_HASH_TRYTES
    }); }));
};
/**
 * Adds signature message fragments to transactions in a bundle starting at offset.
 *
 * @method addTrytes
 *
 * @param {Transaction[]} transactions - List of transactions in the bundle
 *
 * @param {Trytes[]} fragments - List of signature message fragments to add
 *
 * @param {number} [offset = 0] - Optional offset to start appending signature message fragments
 *
 * @return {Transaction[]} List of transactions in the updated bundle
 */
exports.addTrytes = function (transactions, fragments, offset) {
    if (offset === void 0) { offset = 0; }
    return transactions.map(function (transaction, i) {
        return i >= offset && i < offset + fragments.length
            ? __assign({}, transaction, { signatureMessageFragment: pad_1.padTrytes(27 * 81)(fragments[i - offset] || '') }) : transaction;
    });
};
/**
 * Finalizes a bundle by calculating the bundle hash.
 *
 * @method finalizeBundle
 *
 * @param {Transaction[]} transactions - List of transactions in the bundle
 *
 * @return {Transaction[]} List of transactions in the finalized bundle
 */
exports.finalizeBundle = function (transactions) {
    var validBundle = false;
    var valueTrits = transactions.map(function (tx) { return converter_1.trits(tx.value); }).map(pad_1.padTrits(81));
    var timestampTrits = transactions.map(function (tx) { return converter_1.trits(tx.timestamp); }).map(pad_1.padTrits(27));
    var currentIndexTrits = transactions.map(function (tx) { return converter_1.trits(tx.currentIndex); }).map(pad_1.padTrits(27));
    var lastIndexTrits = pad_1.padTrits(27)(converter_1.trits(transactions[0].lastIndex));
    var obsoleteTagTrits = transactions.map(function (tx) { return converter_1.trits(tx.obsoleteTag); }).map(pad_1.padTrits(81));
    var bundleHashTrits = new Int8Array(kerl_1["default"].HASH_LENGTH);
    while (!validBundle) {
        var sponge = new kerl_1["default"]();
        for (var i = 0; i < transactions.length; i++) {
            var essence = converter_1.trits(transactions[i].address +
                converter_1.trytes(valueTrits[i]) +
                converter_1.trytes(obsoleteTagTrits[i]) +
                converter_1.trytes(timestampTrits[i]) +
                converter_1.trytes(currentIndexTrits[i]) +
                converter_1.trytes(lastIndexTrits));
            sponge.absorb(essence, 0, essence.length);
        }
        sponge.squeeze(bundleHashTrits, 0, kerl_1["default"].HASH_LENGTH);
        if (signing_1.normalizedBundle(bundleHashTrits).indexOf(13) !== -1) {
            // Insecure bundle, increment obsoleteTag and recompute bundle hash
            obsoleteTagTrits[0] = signing_1.add(obsoleteTagTrits[0], new Int8Array(1).fill(1));
        }
        else {
            validBundle = true;
        }
    }
    return transactions.map(function (transaction, i) { return (__assign({}, transaction, { 
        // overwrite obsoleteTag in first entry
        obsoleteTag: i === 0 ? converter_1.trytes(obsoleteTagTrits[0]) : transaction.obsoleteTag, bundle: converter_1.trytes(bundleHashTrits) })); });
};
//# sourceMappingURL=index.js.map