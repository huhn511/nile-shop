"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var ava_1 = require("ava");
var errors_1 = require("../../errors");
var src_1 = require("../src");
var HASH_TRITS_SIZE = 243;
var NULL_HASH = '9'.repeat(81);
var NULL_NONCE = '9'.repeat(27);
var addresses = ['A'.repeat(81), 'B'.repeat(81)];
var tag = 'TAG' + '9'.repeat(24);
var bundle = [
    {
        address: addresses[0],
        value: -2,
        tag: tag,
        obsoleteTag: tag,
        currentIndex: 0,
        lastIndex: 2,
        timestamp: 1522219,
        signatureMessageFragment: '9'.repeat(81 * 27),
        trunkTransaction: NULL_HASH,
        branchTransaction: NULL_HASH,
        attachmentTimestamp: 0,
        attachmentTimestampLowerBound: 0,
        attachmentTimestampUpperBound: 0,
        bundle: NULL_HASH,
        nonce: NULL_NONCE,
        hash: NULL_HASH
    },
    {
        address: addresses[0],
        value: 0,
        tag: tag,
        obsoleteTag: tag,
        currentIndex: 1,
        lastIndex: 2,
        timestamp: 1522219,
        signatureMessageFragment: '9'.repeat(81 * 27),
        trunkTransaction: NULL_HASH,
        branchTransaction: NULL_HASH,
        attachmentTimestamp: 0,
        attachmentTimestampLowerBound: 0,
        attachmentTimestampUpperBound: 0,
        bundle: NULL_HASH,
        nonce: NULL_NONCE,
        hash: NULL_HASH
    },
    {
        address: addresses[1],
        value: 2,
        tag: tag,
        obsoleteTag: tag,
        currentIndex: 2,
        lastIndex: 2,
        timestamp: 1522219,
        signatureMessageFragment: '9'.repeat(81 * 27),
        trunkTransaction: NULL_HASH,
        branchTransaction: NULL_HASH,
        attachmentTimestamp: 0,
        attachmentTimestampLowerBound: 0,
        attachmentTimestampUpperBound: 0,
        bundle: NULL_HASH,
        nonce: NULL_NONCE,
        hash: NULL_HASH
    },
];
ava_1["default"]('createBundle() returns correct transactions.', function (t) {
    t.deepEqual(src_1.createBundle([
        {
            length: 2,
            address: addresses[0],
            value: -2,
            tag: 'TAG',
            timestamp: 1522219
        },
        {
            length: 1,
            address: addresses[1],
            value: 2,
            tag: 'TAG',
            timestamp: 1522219
        },
    ]), bundle, 'createBundle() should return correct transactions.');
});
ava_1["default"]('addEntry() adds new entry and returns correct transactions.', function (t) {
    t.deepEqual(src_1.addEntry(bundle.slice(0, 2), {
        length: 1,
        address: addresses[1],
        value: 2,
        tag: 'TAG',
        timestamp: 1522219
    }), bundle, 'addEntry() should add new entry and return correct trasnactions.');
});
ava_1["default"]('addEntry() throws error for entry with value and address with last trit !== 0.', function (t) {
    var invalidAddressTrits = converter_1.trytesToTrits(addresses[1]);
    invalidAddressTrits[HASH_TRITS_SIZE - 1] = 1;
    var invalidAddressTrytes = converter_1.tritsToTrytes(invalidAddressTrits);
    var entry = {
        length: 1,
        address: invalidAddressTrytes,
        value: 1,
        tag: 'TAG',
        timestamp: 1522219
    };
    t.is(t.throws(function () { return src_1.addEntry([], entry); }).message, errors_1.INVALID_ADDRESS_LAST_TRIT, 'addEntry() should throw error for entry with value and address with last trit !== 0.');
    t.is(t.throws(function () { return src_1.addEntry([], __assign({}, entry, { value: -1 })); }).message, errors_1.INVALID_ADDRESS_LAST_TRIT, 'addEntry() should throw error for entry with value and address with last trit !== 0.');
});
ava_1["default"]('addTrytes() adds trytes and returns correct transactions.', function (t) {
    t.deepEqual(src_1.addTrytes(bundle, ['TRYTES', 'TRYTES', 'TRYTES']), bundle.map(function (transaction) { return (__assign({}, transaction, { signatureMessageFragment: 'TRYTES' + '9'.repeat(81 * 27 - 6) })); }), 'addEntry should add trytes and return correct transactions.');
});
ava_1["default"]('finalizeBundle() adds correct bundle hash.', function (t) {
    var bundleHash = 'VRGXKZDODWIVGFYFCCXJRNDCQJVYUVBRIWJXKFGBIEWUPHHTJLTKH99JW9OLJ9JCIXCEIRRXJKLWOBDZZ';
    var incrObsoleteTag = 'ZUH'.concat('9'.repeat(24));
    var expected = bundle.map(function (transaction, i) { return (__assign({}, transaction, { obsoleteTag: i === 0 ? incrObsoleteTag : transaction.obsoleteTag, bundle: bundleHash })); });
    t.deepEqual(src_1.finalizeBundle(bundle), expected, 'finalizeBundle() should add correct bundle hash.');
});
//# sourceMappingURL=bundle.test.js.map