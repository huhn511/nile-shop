"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var samples_1 = require("@iota/samples");
var ava_1 = require("ava");
var src_1 = require("../src");
var constants_1 = require("../src/constants");
ava_1["default"]('isTransaction() returns false for transaction with invalid hash.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { hash: samples_1.transactionObject.hash.slice(1) })), false, 'isTransaction() should return false for transaction with invalid hash.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid signatureMessageFragment.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { signatureMessageFragment: samples_1.transactionObject.signatureMessageFragment.slice(10) })), false, 'isTransaction() should return false for transaction with invalid signatureMessageFragment.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid address.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { address: samples_1.transactionObject.address.slice(1) })), false, 'isTransaction() should return false for transaction with invalid address.');
});
ava_1["default"]('isTransaction() returns true for valid transaction with address (with checksum).', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { address: samples_1.transactionObject.address + "BBIQPUMVW" })), true, 'isTransaction() should return true for valid transaction with address (with checksum).');
});
ava_1["default"]('isTransaction() returns false for value transaction with last trit of address != 0.', function (t) {
    var invalidAddressTrits = converter_1.trytesToTrits(samples_1.transactionObject.address);
    invalidAddressTrits[constants_1.HASH_TRITS_SIZE - 1] = 1;
    var invalidAddressTrytes = converter_1.tritsToTrytes(invalidAddressTrits);
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { value: 1, address: invalidAddressTrytes })), false, 'isTransaction() should return false for value transaction with last trit of address != 0.');
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { value: -1, address: invalidAddressTrytes })), false, 'isTransaction() should return false for value transaction with last trit of address != 0.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer value.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { value: '0' })), false, 'isTransaction() should return false for transaction with non-integer value.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid obsoleteTag.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { obsoleteTag: samples_1.transactionObject.obsoleteTag.slice(1) })), false, 'isTransaction() should return false for transaction with invalid obsoleteTag.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer timestamp.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { timestamp: samples_1.transactionObject.timestamp.toString() })), false, 'isTransaction() should return false for transaction with non-integer timestamp.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer currentIndex.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { currentIndex: '0' })), false, 'isTransaction() should return false for transaction with non-integer currentIndex.');
});
ava_1["default"]('isTransaction() returns false for transaction with negative currentIndex.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { currentIndex: -2 })), false, 'isTransaction() should return false for transaction with negative currentIndex.');
});
ava_1["default"]('isTransaction() returns false for transaction with currentIndex greater than lastIndex.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { currentIndex: 3 })), false, 'isTransaction() should return false for transaction with currentIndex greater than lastIndex.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer lastIndex.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { lastIndex: samples_1.transactionObject.lastIndex.toString() })), false, 'isTransaction() should return false for transaction with non-integer lastIndex.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid bundle.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { bundle: samples_1.transactionObject.bundle.slice(1) })), false, 'isTransaction() should return false for transaction with invalid bundle.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid trunkTransaction.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { trunkTransaction: samples_1.transactionObject.trunkTransaction.slice(1) })), false, 'isTransaction() should return false for transaction with invalid trunkTransaction.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid branchTransaction.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { branchTransaction: samples_1.transactionObject.branchTransaction.slice(1) })), false, 'isTransaction() should return false for transaction with invalid branchTransaction.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid tag.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { tag: samples_1.transactionObject.tag.slice(1) })), false, 'isTransaction() should return false for transaction with invalid tag.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer attachmentTimestamp.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { attachmentTimestamp: samples_1.transactionObject.attachmentTimestamp.toString() })), false, 'isTransaction() should return false for transaction with non-integer attachmentTimestamp.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer attachmentTimestampLowerBound.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { attachmentTimestampLowerBound: samples_1.transactionObject.attachmentTimestampLowerBound.toString() })), false, 'isTransaction() should return false for transaction with non-integer attachmentTimestampLowerBound.');
});
ava_1["default"]('isTransaction() returns false for transaction with non-integer attachmentTimestampUpperBound.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { attachmentTimestampUpperBound: samples_1.transactionObject.attachmentTimestampUpperBound.toString() })), false, 'isTransaction() should return false for transaction with non-integer attachmentTimestampUpperBound.');
});
ava_1["default"]('isTransaction() returns false for transaction with invalid nonce.', function (t) {
    t.is(src_1.isTransaction(__assign({}, samples_1.transactionObject, { nonce: samples_1.transactionObject.nonce.slice(1) })), false, 'isTransaction() should return false for transaction with invalid nonce.');
});
ava_1["default"]('isTransaction() returns true for valid transaction.', function (t) {
    t.is(src_1.isTransaction(samples_1.transactionObject), true, 'isTransaction() should return false for valid transaction.');
});
//# sourceMappingURL=isTransaction.test.js.map