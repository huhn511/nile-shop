"use strict";
/**
 * @module transaction
 */
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var curl_1 = require("@iota/curl");
var errors = require("../../errors");
var guards_1 = require("../../guards");
require("../../typed-array");
var constants_1 = require("./constants");
/**
 * Calculates the transaction hash out of 8019 transaction trits.
 *
 * @method transactionHash
 *
 * @param {Int8Array} trits - Int8Array of 8019 transaction trits
 *
 * @return {Hash} Transaction hash
 */
exports.transactionHash = function (trits) {
    var hash = new Int8Array(curl_1["default"].HASH_LENGTH);
    var curl = new curl_1["default"]();
    // generate the transaction hash
    curl.initialize();
    curl.absorb(trits, 0, trits.length);
    curl.squeeze(hash, 0, curl_1["default"].HASH_LENGTH);
    return converter_1.tritsToTrytes(hash);
};
/* Type guards */
/**
 * Checks if input is valid transaction object.
 *
 * @method isTransaction
 *
 * @param {object} tx
 *
 * @return {boolean}
 */
exports.isTransaction = function (tx) {
    return guards_1.isHash(tx.hash) &&
        guards_1.isTrytesOfExactLength(tx.signatureMessageFragment, constants_1.SIGNATURE_MESSAGE_FRAGMENT_TRYTES_SIZE) &&
        guards_1.isHash(tx.address) &&
        Number.isInteger(tx.value) &&
        guards_1.isTrytesOfExactLength(tx.obsoleteTag, constants_1.OBSOLETE_TAG_TRYTES_SIZE) &&
        Number.isInteger(tx.timestamp) &&
        (Number.isInteger(tx.currentIndex) && tx.currentIndex >= 0 && tx.currentIndex <= tx.lastIndex) &&
        Number.isInteger(tx.lastIndex) &&
        guards_1.isHash(tx.bundle) &&
        guards_1.isHash(tx.trunkTransaction) &&
        guards_1.isHash(tx.branchTransaction) &&
        guards_1.isTrytesOfExactLength(tx.tag, constants_1.TAG_TRYTES_SIZE) &&
        Number.isInteger(tx.attachmentTimestamp) &&
        Number.isInteger(tx.attachmentTimestampLowerBound) &&
        Number.isInteger(tx.attachmentTimestampUpperBound) &&
        guards_1.isTrytesOfExactLength(tx.nonce, constants_1.NONCE_TRYTES_SIZE) &&
        // Check that last trit of address with balance is 0.
        (tx.value === 0 || converter_1.trytesToTrits(tx.address)[constants_1.HASH_TRITS_SIZE - 1] === 0);
};
/**
 * Checks if given transaction object is tail transaction.
 * A tail transaction is one with `currentIndex=0`.
 *
 * @method isTailTransaction
 *
 * @param {object} transaction
 *
 * @return {boolean}
 */
exports.isTailTransaction = function (transaction) {
    return exports.isTransaction(transaction) && transaction.currentIndex === 0;
};
/**
 * Checks if input is correct transaction hash (81 trytes)
 *
 * @method isTransactionHash
 *
 * @param {string} hash
 * @param {number} mwm
 *
 * @return {boolean}
 */
exports.isTransactionHash = function (hash, minWeightMagnitude) {
    var hasCorrectHashLength = guards_1.isTrytesOfExactLength(hash, constants_1.HASH_TRYTES_SIZE);
    if (minWeightMagnitude) {
        return (hasCorrectHashLength &&
            converter_1.trytesToTrits(hash)
                .slice(-Math.abs(minWeightMagnitude))
                .every(function (trit) { return trit === 0; }));
    }
    return hasCorrectHashLength;
};
/**
 * Checks if input is correct transaction trytes (2673 trytes)
 *
 * @method isTransactionTrytes
 *
 * @param {string} trytes
 * @param {number} minWeightMagnitude
 *
 * @return {boolean}
 */
exports.isTransactionTrytes = function (trytes, minWeightMagnitude) {
    var hasCorrectTrytesLength = guards_1.isTrytesOfExactLength(trytes, constants_1.TRANSACTION_TRYTES_SIZE);
    if (minWeightMagnitude) {
        return hasCorrectTrytesLength && exports.isTransactionHash(exports.transactionHash(converter_1.trytesToTrits(trytes)), minWeightMagnitude);
    }
    return hasCorrectTrytesLength;
};
/**
 * Checks if input is valid attached transaction trytes.
 * For attached transactions last 241 trytes are non-zero.
 *
 * @method isAttachedTrytes
 *
 * @param {string} trytes
 *
 * @return {boolean}
 */
exports.isAttachedTrytes = function (trytes) {
    return guards_1.isTrytesOfExactLength(trytes, constants_1.TRANSACTION_TRYTES_SIZE) &&
        !/^[9]+$/.test(trytes.slice(constants_1.TRANSACTION_TRYTES_SIZE - constants_1.HASH_TRITS_SIZE));
};
exports.isAttachedTrytesArray = guards_1.isArray(exports.isAttachedTrytes);
exports.isTransactionArray = guards_1.isArray(exports.isTransaction);
exports.isTransactionHashArray = guards_1.isArray(exports.isTransactionHash);
/* Validators */
exports.transactionValidator = function (transaction) { return [
    transaction,
    exports.isTransaction,
    errors.INVALID_TRANSACTION,
]; };
exports.tailTransactionValidator = function (transaction) { return [
    transaction,
    exports.isTailTransaction,
    errors.INVALID_TAIL_TRANSACTION,
]; };
exports.transactionHashValidator = function (hash, msg) { return [
    hash,
    exports.isTransactionHash,
    msg || errors.INVALID_TRANSACTION_HASH,
]; };
exports.transactionTrytesValidator = function (trytes) { return [
    trytes,
    exports.isTransactionTrytes,
    errors.INVALID_TRANSACTION_TRYTES,
]; };
exports.attachedTrytesValidator = function (trytes) { return [
    trytes,
    exports.isAttachedTrytes,
    errors.INVALID_ATTACHED_TRYTES,
]; };
exports.validateTransaction = function (transaction) { return guards_1.validate(exports.transactionValidator(transaction)); };
exports.validateTailTransaction = function (transaction) { return guards_1.validate(exports.tailTransactionValidator(transaction)); };
exports.validateTransactionHash = function (hash, msg) { return guards_1.validate(exports.transactionHashValidator(hash, msg)); };
exports.validateTransactionTrytes = function (trytes) { return guards_1.validate(exports.transactionTrytesValidator(trytes)); };
exports.validateAttachedTrytes = function (trytes) { return guards_1.validate(exports.attachedTrytesValidator(trytes)); };
//# sourceMappingURL=index.js.map