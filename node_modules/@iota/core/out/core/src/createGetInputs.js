"use strict";
exports.__esModule = true;
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
var _1 = require("./");
var createGetNewAddress_1 = require("./createGetNewAddress");
var defaults = {
    start: 0,
    end: undefined,
    threshold: undefined,
    security: 2
};
/**
 * @method createGetInputs
 *
 * @memberof module:core
 *
 * @param {Provider} provider - Network provider for accessing IRI
 *
 * @return {function} {@link #module_core.getInputs `getInputs`}
 */
exports.createGetInputs = function (provider) {
    var getNewAddress = createGetNewAddress_1.createGetNewAddress(provider, 'lib');
    var getBalances = _1.createGetBalances(provider);
    /**
     * Creates and returns an `Inputs` object by generating addresses and fetching their latest balance.
     *
     * @example
     *
     * ```js
     * getInputs(seed, { start: 0, threhold })
     *   .then(({ inputs, totalBalance }) => {
     *     // ...
     *   })
     *   .catch(err => {
     *     if (err.message === errors.INSUFFICIENT_BALANCE) {
     *        // ...
     *     }
     *     // ...
     *   })
     * ```
     *
     * @method getInputs
     *
     * @memberof module:core
     *
     * @param {string} seed
     * @param {object} [options]
     * @param {number} [options.start=0] - Index offset indicating from which address we start scanning for balance
     * @param {number} [options.end] - Last index up to which we stop scanning
     * @param {number} [options.security=2] - Security level of inputs
     * @param {threshold} [options.threshold] - Minimum amount of balance required
     * @param {Callback} [callback] - Optional callback
     *
     * @return {Promise}
     *
     * @fulfil {Inputs} Inputs object containg a list of `{@link Address}` objects and `totalBalance` field
     * @reject {Error}
     * - `INVALID_SEED`
     * - `INVALID_SECURITY_LEVEL`
     * - `INVALID_START_OPTION`
     * - `INVALID_START_END_OPTIONS`
     * - `INVALID_THRESHOLD`
     * - `INSUFFICIENT_BALANCE`
     * - Fetch error
     */
    return function (seed, options, callback) {
        if (options === void 0) { options = {}; }
        var _a = exports.getInputsOptions(options), start = _a.start, end = _a.end, security = _a.security, threshold = _a.threshold;
        return Promise.resolve(exports.validateGetInputsOptions(seed, { start: start, end: end, security: security, threshold: threshold }))
            .then(function () { return exports.inputsToAddressOptions({ start: start, end: end, security: security, threshold: threshold }); })
            .then(function (newAddressOptions) { return getNewAddress(seed, newAddressOptions); })
            .then(function (allAddresses) { return types_1.asArray(allAddresses); })
            .then(function (allAddresses) {
            return getBalances(allAddresses, 100)
                .then(function (_a) {
                var balances = _a.balances;
                return exports.createInputsObject(allAddresses, balances, start, security);
            })
                .then(function (res) { return exports.filterByThreshold(res, threshold); })
                .tap(function (inputs) { return exports.hasSufficientBalance(inputs, threshold); });
        })
            .asCallback(callback);
    };
};
exports.getInputsOptions = types_1.getOptionsWithDefaults(defaults);
exports.validateGetInputsOptions = function (seed, options) {
    var security = options.security, start = options.start, end = options.end, threshold = options.threshold;
    return guards_1.validate(guards_1.seedValidator(seed), guards_1.securityLevelValidator(security), guards_1.startOptionValidator(start), typeof end !== undefined && guards_1.startEndOptionsValidator({ start: start, end: end }), !!threshold && guards_1.getInputsThresholdValidator(threshold));
};
exports.inputsToAddressOptions = function (_a) {
    var start = _a.start, end = _a.end, security = _a.security;
    return end
        ? createGetNewAddress_1.getNewAddressOptions({ index: start, total: end - start + 1, security: security, returnAll: true })
        : createGetNewAddress_1.getNewAddressOptions({ index: start, security: security, returnAll: true });
};
exports.createInputsObject = function (addresses, balances, start, security) {
    var inputs = addresses
        .map(function (address, i) { return types_1.makeAddress(address, balances[i], start + i, security); })
        .filter(function (address) { return address.balance > 0; });
    var totalBalance = inputs.reduce(function (acc, addr) { return (acc += addr.balance); }, 0);
    return { inputs: inputs, totalBalance: totalBalance };
};
exports.filterByThreshold = function (_a, threshold) {
    var inputs = _a.inputs, totalBalance = _a.totalBalance;
    return threshold
        ? inputs.reduce(function (acc, input) {
            return acc.totalBalance < threshold
                ? { inputs: acc.inputs.concat([input]), totalBalance: acc.totalBalance + input.balance }
                : acc;
        }, { inputs: [], totalBalance: 0 })
        : { inputs: inputs, totalBalance: totalBalance };
};
exports.hasSufficientBalance = function (inputs, threshold) {
    if (threshold && inputs.totalBalance < threshold) {
        throw new Error(errors.INSUFFICIENT_BALANCE);
    }
    return inputs;
};
//# sourceMappingURL=createGetInputs.js.map